# ——————————————————————————————————————————————
# OpenSIPS SIP relay configuration
# listens on 0.0.0.0:5060, records‐routes, and blindly relays based
# on either DNS lookup of the Request‐URI or an explicit next‐hop.
# ——————————————————————————————————————————————

####### global configuration ########
# listen for SIP on UDP port 5060
listen=udp:0.0.0.0:5060

# fork children to handle load (adjust to your cores)
children=4
fork=yes

debug=3
log_stderror=yes

####### module loading ########
loadmodule "proto_udp.so"     # SIP over UDP
loadmodule "sl.so"            # stateless replies
loadmodule "tm.so"            # transaction module
loadmodule "rr.so"            # record‐route
loadmodule "maxfwd.so"        # loop detection
loadmodule "dns.so"           # DNS SRV lookups (for t_relay())

####### module parameters ########
# record‐route so that responses flow back through this proxy
modparam("rr", "enable_double_rr", 1)

# DNS engine (native or c-ares, choose one)
modparam("dns", "dns_engine", "native")

####### request routing logic ########
route {
    # -- drop any unexpected messages
    if (!msg_present()) {
        exit;
    }

    # -- short‐circuit REGISTERs with a 200 OK (i.e. no registrar)
    if (is_method("REGISTER")) {
        sl_send_reply("200", "OK");
        exit;
    }

    # -- normal requests: add Record‐Route so replies come back here
    record_route();

    # -- relay: do a DNS‐based lookup of the Request‐URI domain,
    #    or use an explicitly set $du if you’ve pre-populated dispatcher
    if (!t_relay()) {
        sl_reply_error();
    }
}
